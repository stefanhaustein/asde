const WHITE = newColor(1,1,1)
const BLACK = newColor(0,0,0)
const GREY = newColor(0.5, 0.5, 0.5)

class Vector:
 var x = 0
 var y = 0
 var z = 0

# def new(x: float, y: float, z: float) -> Vector:
#   return Vector{x: x, y: y, z: z}
# end

 def times(self, k: float) -> Vector:
  return newVector(k * self.x, k * self.y, k * self.z)
 end

 def minus(self, v2: Vector) -> Vector:
  return newVector(self.x - v2.x, self.y - v2.y, self.z - v2.z)
 end

 def plus(self, v2: Vector) -> Vector:
  return newVector(self.x + v2.x, self.y + v2.y, self.z + v2.z)
 end

 def dot(self, v2: Vector) -> float:
  return self.x * v2.x + self.y * v2.y + self.z * v2.z
 end

 def mag(self) -> float:
  return sqrt(self.x * self.x + self.y * self.y + self.z * self.z)
 end

 def norm(self) -> Vector:
  return self.times(1/self.mag())
 end

 def cross(self, v2: Vector) -> Vector:
  return newVector(self.y * v2.z - self.z * v2.y, self.z * v2.x - self.x * v2.z, self.x * v2.y - self.y * v2.x)
 end

end

def newVector(x: float, y: float, z: float) -> Vector:
  return Vector{x: x, y: y, z: z}
end

def toByte(n: float) -> float:
 if n <= 0:
   return 0
 elif n >= 1:
   return 255
 end
 return int(n * 255)
end

class Color:
 var r = 0
 var g = 0
 var b = 0

 def scale(self, k: float) -> Color:
  return newColor(k * self.r, k * self.g, k * self.b)
 end

 def plus(self, c2: Color) -> Color:
  return newColor(self.r + c2.r, self.g + c2.g, self.b + c2.b)
 end

 def times(self, c2: Color) -> Color:
  return newColor(self.r * c2.r, self.g * c2.g, self.b * c2.b)
 end

 def toDrawingColor(self) -> float:
  return  255*256*65536 + toByte(self.r) * 65536 + toByte(self.g) * 256 + toByte(self.b)
 end

end


def newColor(r: float, g: float, b: float) -> Color:
 return Color{r: r, g: g, b: b}
end

class Camera:
 var pos: Vector
 var forward: Vector
 var right: Vector
 var up: Vector
end

def newCamera(pos: Vector, lookAt: Vector) -> Camera:
 var down = newVector(0, -1, 0)
 var forward = lookAt.minus(pos).norm()
 var right = forward.cross(down).norm().times(1.5)
 var up = forward.cross(right).norm().times(1.5)
 return Camera{pos: pos, forward: forward, right: right, up: up}
end

class Ray:
 var start: Vector
 var dir: Vector
end

def newRay(start: Vector, dir: Vector) -> Ray:
 return Ray{start: start, dir: dir}
end

class Intersection:
 var thing: Thing
 var ray: Ray
 var dist: float
end

def newIntersection(t: Thing, r: Ray, dist: float) -> Intersection:
 return Intersection{thing: t, ray: r, dist: dist}
end

trait Surface:
 def diffuse(self, pos: Vector) -> Color
 def specular(self, pos: Vector) ->  Color
 def reflect(self, pos: Vector) -> float
 var roughness: float
end

trait Thing:
 def normal(self, pos: Vector) -> Vector
 def intersect(self, ray: Ray) -> Intersection
 var surface: Surface
end

class Light:
 var pos: Vector
 var color: Color
end

def newLight(pos: Vector, color: Color) -> Light:
 return Light{pos: pos, color: color}
end

class Scene:
 var things: List[Thing]
 var lights: List[Light]
 var camera: Camera
 var background: Color
end

class Sphere:
 var center: Vector
 var radius2: float
 var surface: Surface

 def normal(self, pos: Vector) -> Vector:
  return pos.minus(self.center).norm()
 end

 def intersect(self, r: Ray) -> Intersection:
  var eo = self.center.minus(r.start)
  var v = eo.dot(r.dir)
  var dist = 1/0
  if v >= 0 :
   var disc = self.radius2 - (eo.dot(eo) - v * v)
   if disc >= 0 :
     dist = v - sqrt(disc)
   end
  end
  return newIntersection(self, r, dist)
 end

end

def newSphere(center: Vector, radius: float, s: Surface) -> Sphere:
 return Sphere{center: center, radius2: radius * radius, surface: s}
end

class Plane:
 var norm: Vector
 var offset: float
 var surface: Surface

 def normal(self, pos: Vector) -> Vector:
  return self.norm
 end

 def intersect(self, r: Ray) -> Intersection:
  var denom = self.norm.dot(r.dir)
  var dist = 1/0
  if denom <= 0:
    dist = (self.norm.dot(r.start) + self.offset) / (-denom)
  end
  return newIntersection(self, r, dist)
 end

end

def newPlane(normal: Vector, offset: float, s: Surface) -> Plane:
 return Plane{norm: normal, offset: offset, surface: s}
end

class Shiny:
 var roughness = 250

 def diffuse(self, pos: Vector) -> Color:
  return WHITE
 end

 def specular(self, pos: Vector) -> Color:
  return GREY
 end

 def reflect(self, pos: Vector) -> float:
  return 0.7
 end

end

class Checkerboard:
 var roughness = 150

 def diffuse(self, pos: Vector) -> Color:
  if (100000 + floor(pos.z) + floor(pos.x)) % 2 != 0 :
   return WHITE
  else :
   return BLACK
  end
 end

 def specular(self, pos: Vector) -> Color:
  return WHITE
 end

 def reflect(self, pos: Vector) -> float:
  if (1000 + int(pos.z) + int(pos.x)) % 2 != 0 :
   return 0.1
  else :
   return 0.7
  end
 end

end


class RayTracer:
 var maxDepth = 5
 var defaultColor = BLACK

 def intersections(self, r: Ray, s: Scene) -> Intersection:
  var closest = s.things[0].intersect(r)
  for i in range(1, s.things.size):
   var inter = s.things[i].intersect(r)
   if inter.dist < closest.dist :
     closest = inter
   end
  end
  return closest
 end

 def testRay(self, r: Ray, s: Scene) -> float:
  return self.intersections(r, s).dist
 end

 def traceRay(self, r: Ray, s: Scene, depth: float) -> Color:
  var isect = self.intersections(r, s)
  if isect.dist == 1/0 :
   return s.background
  end
  return self.shade(isect, s, depth)
 end

 def shade(self, isect: Intersection, s: Scene, depth: float) -> Color:
  var d = isect.ray.dir
  var pos = d.times(isect.dist).plus(isect.ray.start)
  var normal = isect.thing.normal(pos)
  var reflectDir = d.minus(normal.times(2 * normal.dot(d)))
  var naturalColor = s.background.plus(self.getNaturalColor(isect.thing, pos, normal, reflectDir, s))
  var reflectedColor = GREY
  if depth < self.maxDepth :
   reflectedColor = self.getReflectionColor(isect.thing, pos, normal, reflectDir, s, depth)
  end
  return naturalColor.plus(reflectedColor)
 end

 def getReflectionColor(self, t: Thing, pos: Vector, normal: Vector, rd: Vector, s: Scene, depth: float) -> Color:
  return self.traceRay(newRay(pos, rd), s, depth + 1).scale(t.surface.reflect(pos))
 end

 def addLight(self, t: Thing, pos: Vector, norm: Vector, rd: Vector, s: Scene, col: Color, l: Light) -> Color:
  var ldis = l.pos.minus(pos)
  var livec = ldis.norm()
  var nearIsect = self.testRay(newRay(pos, livec), s)
  var isInShadow = (nearIsect <= ldis.mag())
  if isInShadow :
   return col
  end
  var illum = livec.dot(norm)
  var lcolor = self.defaultColor
  if illum > 0 :
   lcolor = l.color.scale(illum)
  end
  var specular = livec.dot(rd.norm())
  var scolor = self.defaultColor
  if specular > 0 :
   scolor = l.color.scale(specular ^ t.surface.roughness)
  end
  return col.plus(lcolor.times(t.surface.diffuse(pos))).plus(scolor.times(t.surface.specular(pos)))
 end

 def getNaturalColor(self, t: Thing, pos: Vector, norm: Vector, rd: Vector, s: Scene) -> Color:
  var col = self.defaultColor
  for l in s.lights:
   col = self.addLight(t, pos, norm, rd, s, col, l)
  end
  return col
 end

 def getPoint(self, x: float, y: float, cam: Camera) -> Vector:
  return cam.forward.plus(cam.right.times(x / 200)).plus(cam.up.times(y / 200)).norm()
 end

 def render(self, s: Scene, p: Pen, screenWidth: float, screenHeight: float):
  p.strokeColor = 0
  for y in range(screenHeight):
   for x in range(-screenWidth / 2, screenWidth / 2):
     var yy = floor(y / 2)
     if y % 2 == 0:
       yy = -yy
     end
     var color = self.traceRay(newRay(s.camera.pos, self.getPoint(x, yy, s.camera)), s, 0)
     p.fillColor = color.toDrawingColor()
     p.rect(x, yy, 1.5, 1.5)
   end
  end
 end

end

const defaultThings = List[Thing][newPlane(newVector(0,1,0), 0, Checkerboard{}), newSphere(newVector(0,1,-0.25), 1, Shiny{}), newSphere(newVector(-1,0.5,1.5),0.5, Shiny{})]
const defaultLights = [newLight(newVector(-2,2.5,0), newColor(0.49,0.07,0.07)), newLight(newVector(1.5,2.5,1.5), newColor(0.07,0.07,0.49)), newLight(newVector(1.5,2.5,-1.5), newColor(0.07,0.49,0.071)), newLight(newVector(0,3.5,0), newColor(0.21,0.21,0.35))]
const defaultCamera = newCamera(newVector(3,2,4), newVector(-1,0.5,0))
const defaultScene = Scene{background: BLACK, things: defaultThings, lights: defaultLights, camera: defaultCamera}

def main():
 var p = screen.newPen()
 var rayTracer = RayTracer{}
 rayTracer.render(defaultScene, p, screen.width, screen.height)

end